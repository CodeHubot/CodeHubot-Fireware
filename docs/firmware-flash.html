<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›ºä»¶çƒ§å½• - AIOTç³»ç»Ÿä½¿ç”¨æŒ‡å—</title>
    <meta name="description" content="AIOTè®¾å¤‡å›ºä»¶çƒ§å½•æŒ‡å—ï¼ŒWebåœ¨çº¿çƒ§å½•ï¼Œæ— éœ€å®‰è£…è½¯ä»¶">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- å¯¼èˆªæ  -->
    <nav class="navbar">
        <div class="nav-container">
            <a href="index.html" class="logo">
                <span class="logo-icon">ğŸ¤–</span>
                <span>AIOTç³»ç»ŸæŒ‡å—</span>
            </a>
            <button class="menu-toggle">â˜°</button>
            <ul class="nav-menu">
                <li><a href="index.html">é¦–é¡µ</a></li>
                <li><a href="quick-start.html">å¿«é€Ÿå¼€å§‹</a></li>
                <li><a href="admin-panel.html">ç®¡ç†åå°</a></li>
                <li><a href="ai-control.html">Cozeæ’ä»¶</a></li>
                <li><a href="ai-creation.html">æ™ºèƒ½ä½“æ„å»ºå¹³å°</a></li>
                <li><a href="firmware-flash.html" class="active">å›ºä»¶çƒ§å½•</a></li>
                <li><a href="serial-monitor.html">ä¸²å£è°ƒè¯•</a></li>
                <li><a href="troubleshooting.html">å¸®åŠ©ä¸­å¿ƒ</a></li>
            </ul>
        </div>
    </nav>

    <!-- ä¸»å†…å®¹ -->
    <div class="main-container">
        <!-- é¢åŒ…å±‘ -->
        <div class="breadcrumb">
            <a href="index.html">é¦–é¡µ</a>
            <span class="breadcrumb-separator">/</span>
            <span>å›ºä»¶çƒ§å½•</span>
        </div>

        <!-- é¡µé¢å¤´éƒ¨ -->
        <div class="page-header fade-in">
            <h1 class="page-title">ğŸ’¾ å›ºä»¶çƒ§å½•æŒ‡å—</h1>

        </div>

        <!-- å›ºä»¶ä¸‹è½½ -->
        <div class="card fade-in" id="å›ºä»¶ä¸‹è½½">
            <h2 class="card-title">ğŸ“¦ å›ºä»¶ä¸‹è½½</h2>
            <div class="card-content">
                <p style="font-size: 1.1rem; line-height: 1.8; margin-bottom: 25px;">
                    ä»¥ä¸‹æ˜¯å·²ç¼–è¯‘å¥½çš„å›ºä»¶æ–‡ä»¶ï¼Œè¯·æ ¹æ®æ‚¨çš„æ¿å­å‹å·é€‰æ‹©å¯¹åº”çš„å›ºä»¶è¿›è¡Œä¸‹è½½ï¼š
                </p>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 25px;">
                    <!-- ESP32-S3-Dev-01 -->
                    <div style="border: 2px solid #667eea; border-radius: 12px; padding: 25px; background: linear-gradient(135deg, #f8f9ff 0%, #ffffff 100%);">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="font-size: 2.5rem;">ğŸ”·</div>
                            <div>
                                <h3 style="margin: 0; color: #667eea; font-size: 1.3rem;">ESP32-S3-Dev-01</h3>
                                <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: #666;">æ ‡å‡†å¼€å‘æ¿å›ºä»¶</p>
                            </div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 0.9rem; line-height: 1.8; color: #555;">
                                <div style="margin-bottom: 8px;"><strong>ç‰ˆæœ¬ï¼š</strong>v1.5 â­æœ€æ–°ç‰ˆ</div>
                                <div style="margin-bottom: 8px;"><strong>æ–‡ä»¶å¤§å°ï¼š</strong>6.1 MB</div>
                                <div style="margin-bottom: 8px;"><strong>ç‰¹æ€§ï¼š</strong></div>
                                <ul style="margin: 5px 0 0 20px; font-size: 0.85rem;">
                                    <li>DHT11 æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨</li>
                                    <li>DS18B20 é˜²æ°´æ¸©åº¦ä¼ æ„Ÿå™¨</li>
                                    <li>4Ã—LEDç¯ + 2Ã—ç»§ç”µå™¨</li>
                                    <li>1Ã—èˆµæœº M1</li>
                                    <li>1Ã—PWMè¾“å‡º M2</li>
                                </ul>
                            </div>
                        </div>
                        <a href="firmware/ESP32-S3-Dev-01-v1.5.bin" download class="btn btn-primary" style="display: block; text-align: center; padding: 12px 20px; background: #667eea; color: white; border-radius: 6px; text-decoration: none; font-weight: 600;">
                            â¬‡ï¸ ä¸‹è½½å›ºä»¶ (ESP32-S3-Dev-01-v1.5.bin)
                        </a>
                    </div>

                    <!-- ESP32-S3-Rain-01 -->
                    <div style="border: 2px solid #22c55e; border-radius: 12px; padding: 25px; background: linear-gradient(135deg, #f0fdf4 0%, #ffffff 100%);">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="font-size: 2.5rem;">ğŸŒ§ï¸</div>
                            <div>
                                <h3 style="margin: 0; color: #22c55e; font-size: 1.3rem;">ESP32-S3-Rain-01</h3>
                                <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: #666;">é›¨æ°´ä¼ æ„Ÿå™¨ç‰ˆå›ºä»¶</p>
                            </div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 0.9rem; line-height: 1.8; color: #555;">
                                <div style="margin-bottom: 8px;"><strong>ç‰ˆæœ¬ï¼š</strong>v1.5 â­æœ€æ–°ç‰ˆ</div>
                                <div style="margin-bottom: 8px;"><strong>æ–‡ä»¶å¤§å°ï¼š</strong>6.1 MB</div>
                                <div style="margin-bottom: 8px;"><strong>ç‰¹æ€§ï¼š</strong></div>
                                <ul style="margin: 5px 0 0 20px; font-size: 0.85rem;">
                                    <li>DHT11 æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨</li>
                                    <li>é›¨æ°´ä¼ æ„Ÿå™¨</li>
                                    <li>4Ã—LEDç¯ + 2Ã—ç»§ç”µå™¨</li>
                                    <li>2Ã—PWMè¾“å‡º (M1, M2)</li>
                                </ul>
                            </div>
                        </div>
                        <a href="firmware/ESP32-S3-Rain-01-v1.5.bin" download class="btn btn-primary" style="display: block; text-align: center; padding: 12px 20px; background: #22c55e; color: white; border-radius: 6px; text-decoration: none; font-weight: 600;">
                            â¬‡ï¸ ä¸‹è½½å›ºä»¶ (ESP32-S3-Rain-01-v1.5.bin)
                        </a>
                    </div>

                    <!-- ESP32-S3-Lite-01 -->
                    <div style="border: 2px solid #f59e0b; border-radius: 12px; padding: 25px; background: linear-gradient(135deg, #fffbeb 0%, #ffffff 100%);">
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                            <div style="font-size: 2.5rem;">ğŸ’¡</div>
                            <div>
                                <h3 style="margin: 0; color: #f59e0b; font-size: 1.3rem;">ESP32-S3-Lite-01</h3>
                                <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: #666;">ç²¾ç®€ç‰ˆå›ºä»¶</p>
                            </div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 0.9rem; line-height: 1.8; color: #555;">
                                <div style="margin-bottom: 8px;"><strong>ç‰ˆæœ¬ï¼š</strong>v1.7 â­æœ€æ–°ç‰ˆ</div>
                                <div style="margin-bottom: 8px;"><strong>æ–‡ä»¶å¤§å°ï¼š</strong>6.1 MB</div>
                                <div style="margin-bottom: 8px;"><strong>ç‰¹æ€§ï¼š</strong></div>
                                <ul style="margin: 5px 0 0 20px; font-size: 0.85rem;">
                                    <li>DHT11 æ¸©æ¹¿åº¦ä¼ æ„Ÿå™¨</li>
                                    <li>4Ã—LEDç¯</li>
                                    <li>2Ã—ç»§ç”µå™¨</li>
                                    <li>2Ã—PWMè¾“å‡º (M1, M2)</li>
                                    <li>âœ¨ é…ç½‘é¡µé¢æ”¯æŒWiFiå’ŒæœåŠ¡å™¨åœ°å€é…ç½®</li>
                                    <li>ğŸ”§ ä¿®å¤APçƒ­ç‚¹MACåœ°å€æ˜¾ç¤ºé—®é¢˜</li>
                                </ul>
                            </div>
                        </div>
                        <a href="firmware/ESP32-S3-Lite-01-v1.7.bin" download class="btn btn-primary" style="display: block; text-align: center; padding: 12px 20px; background: #f59e0b; color: white; border-radius: 6px; text-decoration: none; font-weight: 600; margin-bottom: 10px;">
                            â¬‡ï¸ ä¸‹è½½å›ºä»¶ v1.7 (ESP32-S3-Lite-01-v1.7.bin)
                        </a>
                        <a href="firmware/ESP32-S3-Lite-01-v1.6.bin" download class="btn btn-secondary" style="display: block; text-align: center; padding: 10px 20px; background: #6b7280; color: white; border-radius: 6px; text-decoration: none; font-size: 0.9rem; margin-bottom: 10px;">
                            ä¸‹è½½ v1.6 æ—§ç‰ˆæœ¬
                        </a>
                        <a href="firmware/ESP32-S3-Lite-01-v1.5.bin" download class="btn btn-secondary" style="display: block; text-align: center; padding: 10px 20px; background: #6b7280; color: white; border-radius: 6px; text-decoration: none; font-size: 0.9rem;">
                            ä¸‹è½½ v1.5 æ—§ç‰ˆæœ¬
                        </a>
                    </div>
                </div>

                <div class="alert alert-info" style="margin-top: 20px;">
                    <div class="alert-icon">ğŸ’¡</div>
                    <div class="alert-content">
                        <div class="alert-title">ç‰ˆæœ¬è¯´æ˜</div>
                        <div style="margin: 10px 0 0 0;">
                            <p style="margin-bottom: 10px;"><strong>v1.7 æœ€æ–°ç‰ˆï¼ˆESP32-S3-Lite-01ï¼‰ï¼š</strong></p>
                            <ul style="margin: 5px 0 0 20px; font-size: 0.9rem;">
                                <li>ğŸ”§ ä¿®å¤APçƒ­ç‚¹MACåœ°å€æ˜¾ç¤ºé—®é¢˜ï¼ˆçƒ­ç‚¹åç§°ç°åœ¨ä½¿ç”¨è®¾å¤‡çœŸå®MACåœ°å€ï¼‰</li>
                                <li>âœ¨ é…ç½‘é¡µé¢æ”¯æŒWiFiå’ŒæœåŠ¡å™¨åœ°å€é…ç½®</li>
                                <li>âœ¨ å¯†ç æ¡†æ”¯æŒæ˜æ–‡/å¯†æ–‡åˆ‡æ¢æ˜¾ç¤º</li>
                                <li>ç¨³å®šç‰ˆæœ¬ï¼Œç³»ç»Ÿå¯ç¨³å®šè¿è¡Œ</li>
                            </ul>
                            <p style="margin-top: 10px;"><strong>v1.6 ç¨³å®šç‰ˆï¼š</strong>é…ç½‘é¡µé¢ä¼˜åŒ–ç‰ˆæœ¬ï¼Œé€‚ç”¨äºLiteæ¿å­ã€‚</p>
                            <p style="margin-top: 5px;"><strong>v1.5 ç¨³å®šç‰ˆï¼š</strong>ä¹‹å‰çš„ç¨³å®šç‰ˆæœ¬ï¼Œé€‚ç”¨äºæ‰€æœ‰æ¿å­å‹å·ã€‚</p>
                        </div>
                    </div>
                </div>

                <div class="alert alert-warning" style="margin-top: 15px;">
                    <div class="alert-icon">âš ï¸</div>
                    <div class="alert-content">
                        <div class="alert-title">é‡è¦æç¤º</div>
                        <ul style="margin: 10px 0 0 0; padding-left: 20px;">
                            <li>è¯·æ ¹æ®æ‚¨çš„æ¿å­å‹å·é€‰æ‹©å¯¹åº”çš„å›ºä»¶ï¼Œä¸è¦æ··ç”¨</li>
                            <li>çƒ§å½•å‰å»ºè®®å…ˆæ“¦é™¤Flashï¼š<code>esptool.py --chip esp32s3 --port &lt;PORT&gt; erase_flash</code></li>
                            <li>å›ºä»¶æ–‡ä»¶ä¸ºåˆå¹¶åçš„å®Œæ•´å›ºä»¶ï¼Œå¯ç›´æ¥çƒ§å½•åˆ°0x0åœ°å€</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- çƒ§å½•åé…ç½® -->
        <div class="card fade-in" id="çƒ§å½•åé…ç½®">
            <h2 class="card-title">âœ… çƒ§å½•å®Œæˆå</h2>
            <div class="card-content">
                <h3 style="margin-bottom: 15px;">éªŒè¯çƒ§å½•ç»“æœ</h3>
                <div class="steps">
                    <div class="step">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <div class="step-title">è§‚å¯ŸLCDæ˜¾ç¤º</div>
                            <div class="step-description">
                                <p>è®¾å¤‡é‡å¯åï¼ŒLCDå±å¹•åº”è¯¥æ˜¾ç¤ºï¼š</p>
                                <div class="code-block">
                                    <pre>AIOT ESP32-S3
Version: x.x.x
Checking WiFi...</pre>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="step">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <div class="step-title">è¿›å…¥é…ç½‘æ¨¡å¼</div>
                            <div class="step-description">
                                <p>é¦–æ¬¡çƒ§å½•åï¼Œè®¾å¤‡ä¼šè‡ªåŠ¨è¿›å…¥é…ç½‘æ¨¡å¼ï¼ŒLCDæ˜¾ç¤ºï¼š</p>
                                <div class="code-block">
                                    <pre>WiFi Setup
AP:AIOT_xxxxxx
URL:192.168.4.1</pre>
                                </div>
                                <p style="margin-top: 10px;">æ¥ä¸‹æ¥è¯·æŒ‰ç…§<a href="quick-start.html#å®Œæˆé…ç½‘">å¿«é€Ÿå¼€å§‹æŒ‡å—</a>å®ŒæˆWiFié…ç½‘ã€‚</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="alert alert-success" style="margin-top: 30px;">
                    <div class="alert-icon">ğŸ‰</div>
                    <div class="alert-content">
                        <div class="alert-title">å›ºä»¶çƒ§å½•æˆåŠŸï¼</div>
                        <p>ç°åœ¨å¯ä»¥å¼€å§‹é…ç½®è®¾å¤‡äº†ï¼š</p>
                        <div style="margin-top: 15px;">
                            <a href="quick-start.html" class="btn btn-primary">â†’ å‰å¾€å¿«é€Ÿå¼€å§‹</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- é¡µè„š -->
    <footer class="footer">
        <div class="footer-content">
            <p>Â© 2025 AIOTæ™ºèƒ½è®¾å¤‡ç®¡ç†ç³»ç»Ÿ | <a href="#">GitHub</a> | <a href="#">æ–‡æ¡£åé¦ˆ</a></p>
            <p style="margin-top: 10px; font-size: 0.875rem;">
                åŸºäºESP32-S3 Â· Made with â¤ï¸
            </p>
        </div>
    </footer>

    <script src="js/main.js"></script>
    <!-- åŠ è½½esptool.jsåº“ -->
    <script type="module">
        // åŠ¨æ€åŠ è½½esptool.js
        async function loadESPTool() {
            try {
                // å°è¯•ä»CDNåŠ è½½esptool.js
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/esptool-js@latest/dist/esptool.js';
                script.type = 'text/javascript';
                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = () => {
                        console.warn('esptool.js CDNåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨Web Serial APIç›´æ¥å®ç°');
                        reject();
                    };
                    document.head.appendChild(script);
                });
                console.log('âœ… esptool.jsåŠ è½½æˆåŠŸ');
                return true;
            } catch (error) {
                console.warn('esptool.jsåŠ è½½å¤±è´¥ï¼Œå°†ä½¿ç”¨Web Serial APIç›´æ¥å®ç°');
                return false;
            }
        }
        
        // åˆå§‹åŒ–
        loadESPTool().then((loaded) => {
            window.ESPToolLoaded = loaded;
            initFlashTool();
        });
    </script>
    <script>
        // ESP32 ROM Bootloaderåè®®å®ç°
        const ESP32_ROM_PROTOCOL = {
            // SLIPåè®®å¸¸é‡
            SLIP_END: 0xC0,
            SLIP_ESC: 0xDB,
            SLIP_ESC_END: 0xDC,
            SLIP_ESC_ESC: 0xDD,
            
            // å‘½ä»¤ç 
            CMD_SYNC: 0x08,
            CMD_SPI_FLASH_BEGIN: 0x02,
            CMD_SPI_FLASH_DATA: 0x03,
            CMD_SPI_FLASH_END: 0x04,
            CMD_SPI_ERASE: 0x0D,
            CMD_READ_REG: 0x0A,
            CMD_WRITE_REG: 0x09,
            
            // å“åº”ç 
            RESP_OK: 0x00,
            RESP_ERROR: 0x01,
            
            // Flashåœ°å€ï¼ˆESP32-S3ä»0x0å¼€å§‹ï¼‰
            FLASH_START_ADDRESS: 0x0,
            
            // å—å¤§å°ï¼ˆ4KBå¯¹é½ï¼‰
            FLASH_BLOCK_SIZE: 0x1000,
            FLASH_WRITE_SIZE: 0x400
        };

        // SLIPç¼–ç 
        function slipEncode(data) {
            const result = [ESP32_ROM_PROTOCOL.SLIP_END];
            for (let i = 0; i < data.length; i++) {
                const byte = data[i];
                if (byte === ESP32_ROM_PROTOCOL.SLIP_END) {
                    result.push(ESP32_ROM_PROTOCOL.SLIP_ESC);
                    result.push(ESP32_ROM_PROTOCOL.SLIP_ESC_END);
                } else if (byte === ESP32_ROM_PROTOCOL.SLIP_ESC) {
                    result.push(ESP32_ROM_PROTOCOL.SLIP_ESC);
                    result.push(ESP32_ROM_PROTOCOL.SLIP_ESC_ESC);
                } else {
                    result.push(byte);
                }
            }
            result.push(ESP32_ROM_PROTOCOL.SLIP_END);
            return new Uint8Array(result);
        }

        // SLIPè§£ç 
        function slipDecode(data) {
            const result = [];
            let i = 0;
            while (i < data.length) {
                if (data[i] === ESP32_ROM_PROTOCOL.SLIP_END) {
                    i++;
                    continue;
                }
                if (data[i] === ESP32_ROM_PROTOCOL.SLIP_ESC) {
                    i++;
                    if (i >= data.length) break;
                    if (data[i] === ESP32_ROM_PROTOCOL.SLIP_ESC_END) {
                        result.push(ESP32_ROM_PROTOCOL.SLIP_END);
                    } else if (data[i] === ESP32_ROM_PROTOCOL.SLIP_ESC_ESC) {
                        result.push(ESP32_ROM_PROTOCOL.SLIP_ESC);
                    } else {
                        result.push(data[i]);
                    }
                } else {
                    result.push(data[i]);
                }
                i++;
            }
            return new Uint8Array(result);
        }

        // CRC16æ ¡éªŒ
        function crc16(data) {
            let crc = 0xFFFF;
            for (let i = 0; i < data.length; i++) {
                crc ^= data[i];
                for (let j = 0; j < 8; j++) {
                    if (crc & 1) {
                        crc = (crc >> 1) ^ 0x8408;
                    } else {
                        crc = crc >> 1;
                    }
                }
            }
            return crc ^ 0xFFFF;
        }

        // æ„å»ºå‘½ä»¤åŒ…
        function buildCommand(cmd, data = new Uint8Array(0), checksum = true) {
            // ESP32å‘½ä»¤æ ¼å¼ï¼š
            // [å‘½ä»¤ç (1å­—èŠ‚)] [æ•°æ®é•¿åº¦(4å­—èŠ‚ï¼Œå°ç«¯)] [ä¿ç•™(3å­—èŠ‚)] [æ•°æ®] [CRC16(2å­—èŠ‚ï¼Œå°ç«¯)]
            const cmdData = new Uint8Array(8 + data.length);
            cmdData[0] = cmd;
            // æ•°æ®é•¿åº¦ï¼ˆå°ç«¯åºï¼‰
            cmdData[1] = data.length & 0xFF;
            cmdData[2] = (data.length >> 8) & 0xFF;
            cmdData[3] = (data.length >> 16) & 0xFF;
            cmdData[4] = (data.length >> 24) & 0xFF;
            // ä¿ç•™å­—èŠ‚ï¼ˆé€šå¸¸ä¸º0ï¼‰
            cmdData[5] = 0x00;
            cmdData[6] = 0x00;
            cmdData[7] = 0x00;
            
            // æ·»åŠ æ•°æ®
            for (let i = 0; i < data.length; i++) {
                cmdData[8 + i] = data[i];
            }
            
            // è®¡ç®—æ ¡éªŒå’Œï¼ˆCRC16ï¼Œä¸åŒ…æ‹¬CRCæœ¬èº«ï¼‰
            if (checksum) {
                const crc = crc16(cmdData.slice(0, 8 + data.length));
                const crcBytes = new Uint8Array(2);
                // CRC16å°ç«¯åº
                crcBytes[0] = crc & 0xFF;
                crcBytes[1] = (crc >> 8) & 0xFF;
                const fullCmd = new Uint8Array(cmdData.length + 2);
                fullCmd.set(cmdData);
                fullCmd.set(crcBytes, cmdData.length);
                return slipEncode(fullCmd);
            }
            
            return slipEncode(cmdData);
        }

        // è¯»å–å“åº”
        async function readResponse(timeout = 5000) {
            const startTime = Date.now();
            let buffer = new Uint8Array(0);
            let slipEndFound = false;
            let lastReadTime = Date.now();
            
            while (Date.now() - startTime < timeout) {
                try {
                    // è®¾ç½®è¯»å–è¶…æ—¶
                    const readTimeout = Math.min(100, timeout - (Date.now() - startTime));
                    if (readTimeout <= 0) break;
                    
                    const readPromise = reader.read();
                    const timeoutPromise = new Promise((resolve) => {
                        setTimeout(() => resolve({ value: null, done: true }), readTimeout);
                    });
                    
                    const result = await Promise.race([readPromise, timeoutPromise]);
                    
                    if (result.done || !result.value) {
                        // å¦‚æœè¶…æ—¶ä¸”å·²ç»æœ‰æ•°æ®ï¼Œå°è¯•è§£æ
                        if (buffer.length > 0 && Date.now() - lastReadTime > 100) {
                            break;
                        }
                        continue;
                    }
                    
                    lastReadTime = Date.now();
                    
                    // åˆå¹¶ç¼“å†²åŒº
                    const newBuffer = new Uint8Array(buffer.length + result.value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(result.value, buffer.length);
                    buffer = newBuffer;
                    
                    // æŸ¥æ‰¾SLIPç»“æŸæ ‡å¿—
                    if (buffer.length > 0 && buffer[buffer.length - 1] === ESP32_ROM_PROTOCOL.SLIP_END) {
                        slipEndFound = true;
                        
                        // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ•°æ®å®Œæ•´
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                        // å†æ¬¡å°è¯•è¯»å–ï¼ˆå¯èƒ½è¿˜æœ‰æ•°æ®ï¼‰
                        try {
                            const { value, done } = await Promise.race([
                                reader.read(),
                                new Promise((resolve) => setTimeout(() => resolve({ value: null, done: true }), 50))
                            ]);
                            if (!done && value) {
                                const finalBuffer = new Uint8Array(buffer.length + value.length);
                                finalBuffer.set(buffer);
                                finalBuffer.set(value, buffer.length);
                                buffer = finalBuffer;
                            }
                        } catch (e) {
                            // å¿½ç•¥
                        }
                        
                        break;
                    }
                } catch (error) {
                    if (error.name === 'NetworkError' || error.name === 'AbortError') {
                        // è¯»å–å™¨å¯èƒ½å·²å…³é—­ï¼Œå°è¯•è§£æå·²æœ‰æ•°æ®
                        if (buffer.length > 0) break;
                    }
                    // å…¶ä»–é”™è¯¯ç»§ç»­
                }
                
                // å°å»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            // å°è¯•è§£æç¼“å†²åŒº
            if (buffer.length > 0) {
                try {
                    // è§£ç SLIP
                    const decoded = slipDecode(buffer);
                    
                    // ESP32å“åº”æ ¼å¼ï¼š[çŠ¶æ€ç (1)] [æ•°æ®é•¿åº¦(4)] [ä¿ç•™(3)] [æ•°æ®] [CRC16(2)]
                    if (decoded.length >= 1) {
                        const status = decoded[0];
                        
                        if (decoded.length >= 5) {
                            // æ•°æ®é•¿åº¦ï¼ˆå°ç«¯åºï¼‰
                            const dataLen = decoded[1] | (decoded[2] << 8) | (decoded[3] << 16) | (decoded[4] << 24);
                            
                            // æå–æ•°æ®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                            let data = new Uint8Array(0);
                            if (decoded.length >= 8 + dataLen) {
                                data = decoded.slice(8, 8 + dataLen);
                            } else if (decoded.length > 8) {
                                data = decoded.slice(8);
                            }
                            
                            return { status, data };
                        } else {
                            // åªæœ‰çŠ¶æ€ç 
                            return { status, data: new Uint8Array(0) };
                        }
                    }
                } catch (e) {
                    // è§£ç å¤±è´¥ï¼Œè¿”å›åŸå§‹æ•°æ®
                    if (buffer.length > 0) {
                        return { status: buffer[0] || 0, data: buffer.slice(1) };
                    }
                }
            }
            
            if (!slipEndFound) {
                throw new Error('è¯»å–å“åº”è¶…æ—¶ï¼šæœªæ”¶åˆ°å®Œæ•´å“åº”');
            }
            
            throw new Error('è¯»å–å“åº”è¶…æ—¶ï¼šæ•°æ®æ ¼å¼é”™è¯¯');
        }

        // ESP32çƒ§å½•å·¥å…·å®ç°
        let serialPort = null;
        let reader = null;
        let writer = null;
        let selectedFile = null;
        let isConnected = false;
        let isFlashing = false;

        function log(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const logContent = document.getElementById('logContent');
            
            if (!logContainer || !logContent) return;
            
            logContainer.style.display = 'block';
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff4444' : type === 'success' ? '#4CAF50' : '#fff';
            logContent.innerHTML += `<span style="color: ${color}">[${timestamp}] ${message}</span>\n`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function updateProgress(percent, text) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const progressPercent = document.getElementById('progressPercent');
            
            if (progressContainer) progressContainer.style.display = 'block';
            if (progressBar) {
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
            }
            if (progressText) progressText.textContent = text || 'çƒ§å½•ä¸­...';
            if (progressPercent) progressPercent.textContent = percent + '%';
        }

        function setButtonState(connected, flashing) {
            const connectBtn = document.getElementById('connectBtn');
            const flashBtn = document.getElementById('flashBtn');
            const eraseBtn = document.getElementById('eraseBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            isConnected = connected;
            isFlashing = flashing;
            
            if (connectBtn) {
                connectBtn.disabled = connected || flashing;
                connectBtn.style.opacity = (connected || flashing) ? '0.5' : '1';
            }
            
            if (flashBtn) {
                flashBtn.disabled = !connected || !selectedFile || flashing;
                flashBtn.style.opacity = (!connected || !selectedFile || flashing) ? '0.5' : '1';
                flashBtn.style.pointerEvents = (!connected || !selectedFile || flashing) ? 'none' : 'auto';
            }
            
            if (eraseBtn) {
                eraseBtn.disabled = !connected || flashing;
                eraseBtn.style.opacity = (!connected || flashing) ? '0.5' : '1';
            }
            
            if (disconnectBtn) {
                disconnectBtn.style.display = connected ? 'inline-block' : 'none';
            }
        }

        // æ£€æŸ¥Web Serial APIæ”¯æŒ
        function checkWebSerialSupport() {
            if (!navigator.serial) {
                alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWeb Serial APIï¼\n\nè¯·ä½¿ç”¨Chrome 89+ã€Edge 89+æˆ–Opera 75+æµè§ˆå™¨ã€‚');
                return false;
            }
            return true;
        }

        // æ¸…ç©ºä¸²å£ç¼“å†²åŒº
        async function flushSerial() {
            try {
                // å–æ¶ˆå½“å‰è¯»å–å¹¶é‡æ–°è·å–reader
                if (reader && serialPort) {
                    try {
                        await reader.cancel();
                    } catch (e) {
                        // å¿½ç•¥å–æ¶ˆé”™è¯¯
                    }
                    try {
                        reader.releaseLock();
                    } catch (e) {
                        // å¿½ç•¥é‡Šæ”¾é”™è¯¯
                    }
                    // é‡æ–°è·å–reader
                    reader = serialPort.readable.getReader();
                }
                
                // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©ç¼“å†²åŒºæ¸…ç©º
                await new Promise(resolve => setTimeout(resolve, 100));
            } catch (e) {
                // å¿½ç•¥é”™è¯¯ï¼Œå°è¯•é‡æ–°è·å–reader
                if (serialPort) {
                    try {
                        reader = serialPort.readable.getReader();
                    } catch (e2) {
                        // å¿½ç•¥
                    }
                }
            }
        }

        // åŒæ­¥ESP32ï¼ˆè¿›å…¥ä¸‹è½½æ¨¡å¼ï¼‰
        async function syncESP32() {
            log('æ­£åœ¨åŒæ­¥ESP32...', 'info');
            
            // å…ˆæ¸…ç©ºä¸²å£ç¼“å†²åŒº
            await flushSerial();
            
            // ESP32åŒæ­¥åºåˆ—ï¼šå…ˆå‘é€åŸå§‹åŒæ­¥å­—èŠ‚ï¼ˆä¸ç»è¿‡SLIPç¼–ç ï¼‰
            // 0x07 0x07 0x12 0x20 + 36å­—èŠ‚0x55
            const syncPattern = new Uint8Array(36);
            syncPattern.fill(0x55);
            const syncBytes = new Uint8Array(40);
            syncBytes[0] = 0x07;
            syncBytes[1] = 0x07;
            syncBytes[2] = 0x12;
            syncBytes[3] = 0x20;
            syncBytes.set(syncPattern, 4);
            
            // å‘é€åŒæ­¥å­—èŠ‚åºåˆ—ï¼ˆåŸå§‹å­—èŠ‚ï¼Œä¸SLIPç¼–ç ï¼‰
            log('å‘é€åŒæ­¥å­—èŠ‚åºåˆ—...', 'info');
            for (let i = 0; i < 8; i++) {
                await writer.write(syncBytes);
                await new Promise(resolve => setTimeout(resolve, 20));
            }
            
            // ç­‰å¾…ESP32å“åº”
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // ç°åœ¨å‘é€SYNCå‘½ä»¤ï¼ˆä½¿ç”¨SLIPç¼–ç ï¼‰
            log('å‘é€SYNCå‘½ä»¤...', 'info');
            const syncData = new Uint8Array([0x07, 0x07, 0x12, 0x20]);
            
            for (let i = 0; i < 10; i++) {
                const syncCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SYNC, syncData);
                await writer.write(syncCmd);
                
                // ç­‰å¾…å“åº”
                await new Promise(resolve => setTimeout(resolve, 50));
                
                try {
                    // å°è¯•è¯»å–å“åº”ï¼ˆè¶…æ—¶æ—¶é—´è¾ƒçŸ­ï¼‰
                    const response = await readResponse(500);
                    if (response && response.status === ESP32_ROM_PROTOCOL.RESP_OK) {
                        log('âœ… ESP32åŒæ­¥æˆåŠŸï¼', 'success');
                        return true;
                    } else if (response) {
                        log(`æ”¶åˆ°å“åº”ï¼ŒçŠ¶æ€ç : 0x${response.status.toString(16)}`, 'info');
                    }
                } catch (e) {
                    // ç»§ç»­å°è¯•
                    if (i === 9) {
                        log(`åŒæ­¥å°è¯• ${i + 1}/10 å¤±è´¥: ${e.message}`, 'info');
                    }
                }
            }
            
            // å¦‚æœæ ‡å‡†SYNCå¤±è´¥ï¼Œå°è¯•ç®€åŒ–ç‰ˆæœ¬
            log('å°è¯•ç®€åŒ–åŒæ­¥å‘½ä»¤...', 'info');
            for (let i = 0; i < 5; i++) {
                const simpleSyncCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SYNC, new Uint8Array(0));
                await writer.write(simpleSyncCmd);
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    const response = await readResponse(500);
                    if (response && response.status === ESP32_ROM_PROTOCOL.RESP_OK) {
                        log('âœ… ESP32åŒæ­¥æˆåŠŸï¼ˆç®€åŒ–æ¨¡å¼ï¼‰ï¼', 'success');
                        return true;
                    }
                } catch (e) {
                    // ç»§ç»­å°è¯•
                }
            }
            
            // å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œæç¤ºç”¨æˆ·æ£€æŸ¥è®¾å¤‡çŠ¶æ€
            log('âš ï¸ åŒæ­¥å¤±è´¥ï¼Œä½†ç»§ç»­å°è¯•çƒ§å½•...', 'info');
            log('æç¤ºï¼šå¦‚æœçƒ§å½•å¤±è´¥ï¼Œè¯·ç¡®ä¿è®¾å¤‡å·²è¿›å…¥ä¸‹è½½æ¨¡å¼', 'info');
            log('è¿›å…¥ä¸‹è½½æ¨¡å¼æ–¹æ³•ï¼šæŒ‰ä½Booté”®ï¼ŒæŒ‰Reseté”®ï¼Œæ¾å¼€Booté”®', 'info');
            
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸ç»§ç»­å°è¯•ï¼ˆæœ‰äº›è®¾å¤‡å¯èƒ½å·²ç»åŒæ­¥ä½†æ²¡è¿”å›å“åº”ï¼‰
            return false;
        }

        // è¿æ¥è®¾å¤‡
        async function connectDevice() {
            if (!checkWebSerialSupport()) return;
            
            try {
                log('æ­£åœ¨è¿æ¥è®¾å¤‡...', 'info');
                const port = await navigator.serial.requestPort();
                const baudrate = parseInt(document.getElementById('baudrate').value);
                
                await port.open({ baudRate: baudrate });
                
                serialPort = port;
                reader = port.readable.getReader();
                writer = port.writable.getWriter();
                
                log(`ä¸²å£å·²æ‰“å¼€ï¼Œæ³¢ç‰¹ç‡: ${baudrate}`, 'info');
                
                // åŒæ­¥ESP32ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰
                log('å¼€å§‹åŒæ­¥ESP32ï¼Œæœ€å¤šç­‰å¾…10ç§’...', 'info');
                const syncPromise = syncESP32();
                const timeoutPromise = new Promise((resolve) => {
                    setTimeout(() => resolve(false), 10000); // 10ç§’è¶…æ—¶
                });
                
                const syncResult = await Promise.race([syncPromise, timeoutPromise]);
                
                if (syncResult === false && !syncPromise.then) {
                    log('âš ï¸ åŒæ­¥è¶…æ—¶ï¼Œä½†ç»§ç»­è¿æ¥ï¼ˆè®¾å¤‡å¯èƒ½å·²å‡†å¤‡å¥½ï¼‰', 'info');
                }
                
                isConnected = true;
                setButtonState(true, false);
                log(`âœ… è®¾å¤‡è¿æ¥æˆåŠŸï¼å¯ä»¥å¼€å§‹çƒ§å½•`, 'success');
                
                // ç›‘å¬æ–­å¼€äº‹ä»¶
                port.addEventListener('disconnect', () => {
                    log('âš ï¸ è®¾å¤‡å·²æ–­å¼€è¿æ¥', 'error');
                    disconnectDevice();
                });
                
            } catch (error) {
                log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                if (error.name === 'NotFoundError') {
                    alert('æœªé€‰æ‹©è®¾å¤‡ï¼Œè¯·é‡è¯•');
                } else if (error.name === 'SecurityError') {
                    alert('æƒé™è¢«æ‹’ç»ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨è®¾ç½®');
                } else {
                    alert('è¿æ¥å¤±è´¥ï¼š' + error.message + '\n\næç¤ºï¼š\n1. ç¡®ä¿è®¾å¤‡å·²è¿›å…¥ä¸‹è½½æ¨¡å¼ï¼ˆæŒ‰ä½Booté”®ï¼ŒæŒ‰Reseté”®ï¼Œæ¾å¼€Booté”®ï¼‰\n2. æ£€æŸ¥USBè¿æ¥æ˜¯å¦æ­£å¸¸\n3. å°è¯•é™ä½æ³¢ç‰¹ç‡ï¼ˆå¦‚115200ï¼‰');
                }
                
                // æ¸…ç†èµ„æº
                if (reader) {
                    try { 
                        await reader.cancel();
                        reader.releaseLock();
                    } catch (e) {}
                    reader = null;
                }
                if (writer) {
                    try { 
                        await writer.close();
                        writer.releaseLock();
                    } catch (e) {}
                    writer = null;
                }
                if (serialPort) {
                    try { await serialPort.close(); } catch (e) {}
                    serialPort = null;
                }
            }
        }

        // æ–­å¼€è¿æ¥
        async function disconnectDevice() {
            try {
                if (reader) {
                    await reader.cancel();
                    reader = null;
                }
                if (writer) {
                    await writer.close();
                    writer = null;
                }
                if (serialPort) {
                    await serialPort.close();
                    serialPort = null;
                }
                
                isConnected = false;
                setButtonState(false, false);
                log('å·²æ–­å¼€è¿æ¥', 'info');
            } catch (error) {
                log(`æ–­å¼€è¿æ¥æ—¶å‡ºé”™: ${error.message}`, 'error');
            }
        }

        // æ“¦é™¤Flash
        async function eraseFlash() {
            if (!isConnected) {
                alert('è¯·å…ˆè¿æ¥è®¾å¤‡ï¼');
                return;
            }
            
            if (!confirm('ç¡®å®šè¦æ“¦é™¤Flashå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼\n\næç¤ºï¼šæ“¦é™¤åéœ€è¦é‡æ–°çƒ§å½•å›ºä»¶ã€‚')) {
                return;
            }
            
            try {
                log('å¼€å§‹æ“¦é™¤Flash...', 'info');
                updateProgress(0, 'æ“¦é™¤ä¸­...');
                setButtonState(true, true);
                
                // é‡æ–°åŒæ­¥ï¼ˆç¡®ä¿è¿æ¥æ­£å¸¸ï¼‰
                await syncESP32();
                
                // å‘é€æ“¦é™¤å‘½ä»¤
                // ESP32æ“¦é™¤å‘½ä»¤æ ¼å¼ï¼šèµ·å§‹åœ°å€(4å­—èŠ‚) + å¤§å°(4å­—èŠ‚)
                const eraseSize = 0x400000; // 4MBï¼ˆESP32-S3é€šå¸¸ä¸º4MBæˆ–8MBï¼‰
                const eraseAddr = ESP32_ROM_PROTOCOL.FLASH_START_ADDRESS;
                
                const eraseData = new Uint8Array(8);
                // åœ°å€ï¼ˆå°ç«¯ï¼‰
                eraseData[0] = eraseAddr & 0xFF;
                eraseData[1] = (eraseAddr >> 8) & 0xFF;
                eraseData[2] = (eraseAddr >> 16) & 0xFF;
                eraseData[3] = (eraseAddr >> 24) & 0xFF;
                // å¤§å°ï¼ˆå°ç«¯ï¼‰
                eraseData[4] = eraseSize & 0xFF;
                eraseData[5] = (eraseSize >> 8) & 0xFF;
                eraseData[6] = (eraseSize >> 16) & 0xFF;
                eraseData[7] = (eraseSize >> 24) & 0xFF;
                
                const eraseCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SPI_ERASE, eraseData);
                await writer.write(eraseCmd);
                
                updateProgress(50, 'æ“¦é™¤ä¸­...');
                
                // è¯»å–å“åº”
                const response = await readResponse(30000); // æ“¦é™¤å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´
                if (response.status === ESP32_ROM_PROTOCOL.RESP_OK) {
                    updateProgress(100, 'æ“¦é™¤å®Œæˆ');
                    log('âœ… Flashæ“¦é™¤å®Œæˆï¼', 'success');
                    
                    setTimeout(() => {
                        updateProgress(0, '');
                        document.getElementById('progressContainer').style.display = 'none';
                    }, 2000);
                } else {
                    throw new Error('æ“¦é™¤å‘½ä»¤è¿”å›é”™è¯¯');
                }
                
            } catch (error) {
                log(`âŒ æ“¦é™¤å¤±è´¥: ${error.message}`, 'error');
                alert('æ“¦é™¤å¤±è´¥ï¼š' + error.message);
            } finally {
                setButtonState(true, false);
            }
        }

        // çƒ§å½•å›ºä»¶
        async function flashFirmware() {
            if (!isConnected) {
                alert('è¯·å…ˆè¿æ¥è®¾å¤‡ï¼');
                return;
            }
            
            if (!selectedFile) {
                alert('è¯·å…ˆé€‰æ‹©å›ºä»¶æ–‡ä»¶ï¼');
                return;
            }
            
            try {
                log('å¼€å§‹çƒ§å½•å›ºä»¶...', 'info');
                updateProgress(0, 'å‡†å¤‡ä¸­...');
                setButtonState(true, true);
                
                // é‡æ–°åŒæ­¥ï¼ˆç¡®ä¿è¿æ¥æ­£å¸¸ï¼‰
                await syncESP32();
                
                // è¯»å–æ–‡ä»¶
                const fileData = await selectedFile.arrayBuffer();
                const fileSize = fileData.byteLength;
                const fileView = new Uint8Array(fileData);
                
                log(`æ–‡ä»¶å¤§å°: ${(fileSize / 1024 / 1024).toFixed(2)} MB`, 'info');
                
                // å‘é€SPI_FLASH_BEGINå‘½ä»¤
                // å‚æ•°ï¼šæ€»å¤§å°(4å­—èŠ‚) + å—æ•°é‡(4å­—èŠ‚) + å—å¤§å°(4å­—èŠ‚) + åç§»åœ°å€(4å­—èŠ‚)
                const blockSize = ESP32_ROM_PROTOCOL.FLASH_WRITE_SIZE; // 1024å­—èŠ‚
                const numBlocks = Math.ceil(fileSize / blockSize);
                const flashAddr = ESP32_ROM_PROTOCOL.FLASH_START_ADDRESS;
                
                const beginData = new Uint8Array(16);
                // æ€»å¤§å°ï¼ˆå°ç«¯ï¼‰
                beginData[0] = fileSize & 0xFF;
                beginData[1] = (fileSize >> 8) & 0xFF;
                beginData[2] = (fileSize >> 16) & 0xFF;
                beginData[3] = (fileSize >> 24) & 0xFF;
                // å—æ•°é‡ï¼ˆå°ç«¯ï¼‰
                beginData[4] = numBlocks & 0xFF;
                beginData[5] = (numBlocks >> 8) & 0xFF;
                beginData[6] = (numBlocks >> 16) & 0xFF;
                beginData[7] = (numBlocks >> 24) & 0xFF;
                // å—å¤§å°ï¼ˆå°ç«¯ï¼‰
                beginData[8] = blockSize & 0xFF;
                beginData[9] = (blockSize >> 8) & 0xFF;
                beginData[10] = (blockSize >> 16) & 0xFF;
                beginData[11] = (blockSize >> 24) & 0xFF;
                // åç§»åœ°å€ï¼ˆå°ç«¯ï¼‰
                beginData[12] = flashAddr & 0xFF;
                beginData[13] = (flashAddr >> 8) & 0xFF;
                beginData[14] = (flashAddr >> 16) & 0xFF;
                beginData[15] = (flashAddr >> 24) & 0xFF;
                
                log('å‘é€SPI_FLASH_BEGINå‘½ä»¤...', 'info');
                const beginCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SPI_FLASH_BEGIN, beginData);
                await writer.write(beginCmd);
                
                const beginResponse = await readResponse(5000);
                if (beginResponse.status !== ESP32_ROM_PROTOCOL.RESP_OK) {
                    throw new Error('SPI_FLASH_BEGINå‘½ä»¤å¤±è´¥');
                }
                log('âœ… SPI_FLASH_BEGINæˆåŠŸ', 'success');
                
                // å‘é€æ•°æ®å—
                updateProgress(5, 'å¼€å§‹å†™å…¥æ•°æ®...');
                let totalWritten = 0;
                
                for (let blockIndex = 0; blockIndex < numBlocks; blockIndex++) {
                    const blockStart = blockIndex * blockSize;
                    const blockEnd = Math.min(blockStart + blockSize, fileSize);
                    const blockData = fileView.slice(blockStart, blockEnd);
                    
                    // å¦‚æœå—æ•°æ®ä¸è¶³blockSizeï¼Œéœ€è¦å¡«å……0xFF
                    let paddedBlock = blockData;
                    if (blockData.length < blockSize) {
                        paddedBlock = new Uint8Array(blockSize);
                        paddedBlock.fill(0xFF);
                        paddedBlock.set(blockData);
                    }
                    
                    // æ„å»ºSPI_FLASH_DATAå‘½ä»¤
                    // å‚æ•°ï¼šæ•°æ®å¤§å°(4å­—èŠ‚) + åºåˆ—å·(4å­—èŠ‚) + æ•°æ®(æœ€å¤šblockSizeå­—èŠ‚)
                    const dataCmdData = new Uint8Array(8 + paddedBlock.length);
                    // æ•°æ®å¤§å°ï¼ˆå°ç«¯ï¼‰
                    dataCmdData[0] = paddedBlock.length & 0xFF;
                    dataCmdData[1] = (paddedBlock.length >> 8) & 0xFF;
                    dataCmdData[2] = (paddedBlock.length >> 16) & 0xFF;
                    dataCmdData[3] = (paddedBlock.length >> 24) & 0xFF;
                    // åºåˆ—å·ï¼ˆå°ç«¯ï¼‰
                    dataCmdData[4] = blockIndex & 0xFF;
                    dataCmdData[5] = (blockIndex >> 8) & 0xFF;
                    dataCmdData[6] = (blockIndex >> 16) & 0xFF;
                    dataCmdData[7] = (blockIndex >> 24) & 0xFF;
                    // æ•°æ®
                    dataCmdData.set(paddedBlock, 8);
                    
                    const dataCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SPI_FLASH_DATA, dataCmdData);
                    await writer.write(dataCmd);
                    
                    // è¯»å–å“åº”
                    const dataResponse = await readResponse(5000);
                    if (dataResponse.status !== ESP32_ROM_PROTOCOL.RESP_OK) {
                        throw new Error(`SPI_FLASH_DATAå‘½ä»¤å¤±è´¥ï¼Œå— ${blockIndex + 1}/${numBlocks}`);
                    }
                    
                    totalWritten += blockData.length;
                    const percent = Math.floor((totalWritten / fileSize) * 90) + 5; // 5-95%
                    updateProgress(percent, `å†™å…¥ä¸­... ${blockIndex + 1}/${numBlocks} (${(totalWritten / 1024).toFixed(0)} KB)`);
                    
                    // å°å»¶è¿Ÿé¿å…ç¼“å†²åŒºæº¢å‡º
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                log('âœ… æ‰€æœ‰æ•°æ®å—å†™å…¥å®Œæˆ', 'success');
                
                // å‘é€SPI_FLASH_ENDå‘½ä»¤
                // å‚æ•°ï¼šè¿›å…¥Flashæ¨¡å¼æ ‡å¿—(1å­—èŠ‚ï¼Œ0=ä¸è¿›å…¥ï¼Œ1=è¿›å…¥)
                const endData = new Uint8Array([0x01]); // è¿›å…¥Flashæ¨¡å¼
                
                log('å‘é€SPI_FLASH_ENDå‘½ä»¤...', 'info');
                const endCmd = buildCommand(ESP32_ROM_PROTOCOL.CMD_SPI_FLASH_END, endData);
                await writer.write(endCmd);
                
                const endResponse = await readResponse(5000);
                if (endResponse.status !== ESP32_ROM_PROTOCOL.RESP_OK) {
                    throw new Error('SPI_FLASH_ENDå‘½ä»¤å¤±è´¥');
                }
                
                updateProgress(100, 'çƒ§å½•å®Œæˆ');
                log('âœ… å›ºä»¶çƒ§å½•å®Œæˆï¼è®¾å¤‡å°†è‡ªåŠ¨é‡å¯ã€‚', 'success');
                alert('âœ… å›ºä»¶çƒ§å½•æˆåŠŸï¼è®¾å¤‡å°†è‡ªåŠ¨é‡å¯ã€‚');
                
                setTimeout(() => {
                    updateProgress(0, '');
                    document.getElementById('progressContainer').style.display = 'none';
                }, 3000);
                
            } catch (error) {
                log(`âŒ çƒ§å½•å¤±è´¥: ${error.message}`, 'error');
                alert('çƒ§å½•å¤±è´¥ï¼š' + error.message + '\n\nè¯·æ£€æŸ¥ï¼š\n1. è®¾å¤‡æ˜¯å¦å·²è¿›å…¥ä¸‹è½½æ¨¡å¼\n2. æ³¢ç‰¹ç‡æ˜¯å¦æ­£ç¡®\n3. USBè¿æ¥æ˜¯å¦ç¨³å®š');
            } finally {
                setButtonState(true, false);
            }
        }

        // æ–‡ä»¶é€‰æ‹©å¤„ç†
        function initFlashTool() {
            const firmwareFileInput = document.getElementById('firmwareFile');
            const fileNameDisplay = document.getElementById('fileName');
            const connectBtn = document.getElementById('connectBtn');
            const flashBtn = document.getElementById('flashBtn');
            const eraseBtn = document.getElementById('eraseBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            // æ–‡ä»¶é€‰æ‹©
            if (firmwareFileInput) {
                firmwareFileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        if (!file.name.toLowerCase().endsWith('.bin')) {
                            alert('è¯·é€‰æ‹©.binæ ¼å¼çš„å›ºä»¶æ–‡ä»¶ï¼');
                            firmwareFileInput.value = '';
                            selectedFile = null;
                            if (fileNameDisplay) fileNameDisplay.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                            setButtonState(isConnected, false);
                            return;
                        }
                        
                        selectedFile = file;
                        const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
                        if (fileNameDisplay) {
                            fileNameDisplay.textContent = `âœ… ${file.name} (${fileSizeMB} MB)`;
                        }
                        log(`å·²é€‰æ‹©æ–‡ä»¶: ${file.name} (${fileSizeMB} MB)`, 'info');
                        setButtonState(isConnected, false);
                    } else {
                        selectedFile = null;
                        if (fileNameDisplay) fileNameDisplay.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                        setButtonState(isConnected, false);
                    }
                });
            }
            
            // æŒ‰é’®äº‹ä»¶
            if (connectBtn) {
                connectBtn.addEventListener('click', connectDevice);
            }
            
            if (flashBtn) {
                flashBtn.addEventListener('click', flashFirmware);
            }
            
            if (eraseBtn) {
                eraseBtn.addEventListener('click', eraseFlash);
            }
            
            if (disconnectBtn) {
                disconnectBtn.addEventListener('click', disconnectDevice);
            }
            
            // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
            setButtonState(false, false);
        }
    </script>
</body>
</html>

